{"version":3,"sources":["../../../../src/steps/source-nodes/update-nodes/content-update-interval.js"],"names":["checkForNodeUpdates","cache","emitter","lastCompletedSourceTime","get","LAST_COMPLETED_SOURCE_TIME","since","data","actionMonitorActions","nodes","newActions","query","contentPollingQuery","variables","throwGqlErrors","throwFetchErrors","length","store","dispatch","develop","pauseRefreshPolling","emit","webhookBody","refreshing","set","Date","now","refetcher","msRefetchInterval","helpers","reconnectionActivity","retryCount","refreshPollingIsPaused","getState","end","reporter","success","e","pluginOptions","debug","throwRefetchErrors","activityTimer","message","start","setStatus","retryTime","maxWait","waitFor","Promise","resolve","setTimeout","startPollingForContentUpdates","process","env","WP_DISABLE_POLLING","ENABLE_GATSBY_REFRESH_ENDPOINT","verbose","gatsbyApi","nodeUpdateInterval","log","info"],"mappings":"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","sourcesContent":["import { formatLogMessage } from \"~/utils/format-log-message\"\nimport store from \"~/store\"\nimport { getGatsbyApi } from \"~/utils/get-gatsby-api\"\nimport { contentPollingQuery } from \"../../../utils/graphql-queries\"\nimport fetchGraphql from \"../../../utils/fetch-graphql\"\nimport { LAST_COMPLETED_SOURCE_TIME } from \"../../../constants\"\n\n/**\n * This function checks wether there is atleast 1 WPGatsby action ready to be processed by Gatsby\n * If there is, it calls the refresh webhook so that schema customization and source nodes run again.\n */\nconst checkForNodeUpdates = async ({ cache, emitter }) => {\n  // get the last sourced time\n  const lastCompletedSourceTime = await cache.get(LAST_COMPLETED_SOURCE_TIME)\n  const since = lastCompletedSourceTime - 500\n\n  // make a graphql request for any actions that have happened since\n  const {\n    data: {\n      actionMonitorActions: { nodes: newActions },\n    },\n  } = await fetchGraphql({\n    query: contentPollingQuery,\n    variables: {\n      since,\n    },\n    // throw fetch errors and graphql errors so we can auto recover in refetcher()\n    throwGqlErrors: true,\n    throwFetchErrors: true,\n  })\n\n  if (newActions.length) {\n    // if there's atleast 1 new action, pause polling,\n    // refresh Gatsby schema+nodes and continue on\n    store.dispatch.develop.pauseRefreshPolling()\n\n    emitter.emit(`WEBHOOK_RECEIVED`, {\n      webhookBody: {\n        since,\n        refreshing: true,\n      },\n    })\n  } else {\n    // set new last completed source time and move on\n    await cache.set(LAST_COMPLETED_SOURCE_TIME, Date.now())\n  }\n}\n\nconst refetcher = async (\n  msRefetchInterval,\n  helpers,\n  { reconnectionActivity = null, retryCount = 1 } = {}\n) => {\n  try {\n    const { refreshPollingIsPaused } = store.getState().develop\n\n    if (!refreshPollingIsPaused) {\n      await checkForNodeUpdates(helpers)\n    }\n\n    if (reconnectionActivity) {\n      reconnectionActivity.end()\n      helpers.reporter.success(\n        formatLogMessage(\n          `Content updates re-connected after ${retryCount} ${\n            retryCount === 1 ? `try` : `tries`\n          }`\n        )\n      )\n\n      reconnectionActivity = null\n      retryCount = 1\n    }\n  } catch (e) {\n    const { pluginOptions } = getGatsbyApi()\n    if (pluginOptions?.debug?.throwRefetchErrors) {\n      throw e\n    }\n\n    if (!reconnectionActivity) {\n      reconnectionActivity = helpers.reporter.activityTimer(\n        formatLogMessage(`Content update error: \"${e.message}\"`)\n      )\n      reconnectionActivity.start()\n      reconnectionActivity.setStatus(`retrying...`)\n    } else {\n      retryCount++\n      reconnectionActivity.setStatus(`retried ${retryCount} times`)\n    }\n\n    // retry after retry count times 5 seconds\n    const retryTime = retryCount * 5000\n    // if the retry time is greater than or equal to the max (60 seconds)\n    // use the max, otherwise use the retry time\n    const maxWait = 60000\n    const waitFor = retryTime >= maxWait ? maxWait : retryTime\n\n    await new Promise(resolve => setTimeout(resolve, waitFor))\n  }\n\n  setTimeout(\n    () =>\n      refetcher(msRefetchInterval, helpers, {\n        reconnectionActivity,\n        retryCount,\n      }),\n    msRefetchInterval\n  )\n}\n\n/**\n * Starts constantly refetching the latest WordPress changes\n * so we can update Gatsby nodes when data changes\n */\nconst startPollingForContentUpdates = helpers => {\n  if (\n    process.env.WP_DISABLE_POLLING ||\n    process.env.ENABLE_GATSBY_REFRESH_ENDPOINT\n  ) {\n    return\n  }\n\n  const { verbose, develop } = store.getState().gatsbyApi.pluginOptions\n\n  const msRefetchInterval = develop.nodeUpdateInterval\n\n  if (verbose) {\n    helpers.reporter.log(``)\n    helpers.reporter.info(formatLogMessage`Watching for WordPress changes`)\n  }\n\n  refetcher(msRefetchInterval, helpers)\n}\n\nexport { startPollingForContentUpdates }\n"],"file":"content-update-interval.js"}