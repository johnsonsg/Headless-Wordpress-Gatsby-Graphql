{"version":3,"sources":["../../../../src/steps/ingest-remote-schema/build-queries-from-introspection/recursively-transform-fields.js"],"names":["transformInlineFragments","possibleTypes","gatsbyNodesInfo","typeMap","maxDepth","parentType","mainType","parentField","fragments","circularQueryLimit","buildGatsbyNodeFields","debug","depth","buildingFragment","ancestorTypeNames","parentAncestorTypeNames","state","store","getState","remoteSchema","pluginOptions","gatsbyApi","schema","queryDepth","transformedInlineFragments","map","possibleType","type","get","name","typeSettings","exclude","dispatch","addFetchedType","isAGatsbyNode","typeNames","includes","fields","typeInfo","filteredFields","kind","filter","filteredField","find","recursivelyTransformFields","length","Boolean","countIncarnations","typeName","ancestorTypeName","transformField","field","fieldBlacklist","fieldAliases","typeKind","typeIncarnationCount","createFragment","fieldName","args","arg","fieldType","ofType","isListOfGatsbyNodes","isListOfMediaItems","hasIdField","listOfType","transformedFields","inlineFragments","isAMediaItemNode","isAnInterfaceType","parentFieldName","previouslyCreatedFragment","fragmentFields","reduce","fieldTypeName","innerFieldField","transformedField","push","queryType","transformFields","fragment","fragmentField","internalType","fieldInlineFragment","fragmentInlineFragment","fieldTypeKind","fieldOfTypeKind","typeKindsRequiringSelectionSets","fieldNeedsSelectionSet","grandParentTypeName","recursivelyTransformedFields"],"mappings":"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","sourcesContent":["import store from \"~/store\"\nimport {\n  getTypeSettingsByType,\n  findTypeName,\n  findTypeKind,\n} from \"~/steps/create-schema-customization/helpers\"\nimport { fieldIsExcludedOnParentType } from \"~/steps/ingest-remote-schema/is-excluded\"\nimport { returnAliasedFieldName } from \"~/steps/create-schema-customization/transform-fields\"\n\nexport const transformInlineFragments = ({\n  possibleTypes,\n  gatsbyNodesInfo,\n  typeMap,\n  maxDepth,\n  parentType,\n  mainType,\n  parentField,\n  fragments,\n  circularQueryLimit,\n  buildGatsbyNodeFields = false,\n  debug = false,\n  depth = 0,\n  buildingFragment = false,\n  ancestorTypeNames: parentAncestorTypeNames = [],\n}) => {\n  const state = store.getState()\n\n  if (!typeMap) {\n    typeMap = state.remoteSchema.typeMap\n  }\n\n  const { pluginOptions } = state.gatsbyApi\n\n  if (!maxDepth) {\n    maxDepth = pluginOptions.schema.queryDepth\n  }\n\n  if (!circularQueryLimit) {\n    circularQueryLimit = pluginOptions.circularQueryLimit\n  }\n\n  if (!gatsbyNodesInfo) {\n    gatsbyNodesInfo = state.remoteSchema.gatsbyNodesInfo\n  }\n\n  const ancestorTypeNames = [...parentAncestorTypeNames]\n\n  const transformedInlineFragments = possibleTypes\n    .map((possibleType) => {\n      possibleType = { ...possibleType }\n\n      const type = typeMap.get(possibleType.name)\n\n      if (!type) {\n        return false\n      }\n\n      const typeSettings = getTypeSettingsByType(type)\n\n      if (typeSettings.exclude) {\n        return false\n      }\n\n      possibleType.type = { ...type }\n\n      // save this type so we can use it in schema customization\n      store.dispatch.remoteSchema.addFetchedType(type)\n\n      const isAGatsbyNode = gatsbyNodesInfo.typeNames.includes(\n        possibleType.name\n      )\n\n      if (isAGatsbyNode && !buildGatsbyNodeFields) {\n        // we use the id to link to the top level Gatsby node\n        possibleType.fields = [`id`]\n        return possibleType\n      }\n\n      const typeInfo = typeMap.get(possibleType.name)\n\n      let filteredFields = [...typeInfo.fields]\n\n      if (parentType?.kind === `INTERFACE`) {\n        // remove any fields from our fragment if the parent type already has them as shared fields\n        filteredFields = filteredFields.filter(\n          (filteredField) =>\n            !parentType.fields.find(\n              (parentField) => parentField.name === filteredField.name\n            )\n        )\n      }\n\n      if (typeInfo) {\n        const fields = recursivelyTransformFields({\n          fields: filteredFields,\n          parentType: type,\n          depth,\n          ancestorTypeNames,\n          fragments,\n          buildingFragment,\n          circularQueryLimit,\n          mainType,\n          parentField,\n        })\n\n        if (!fields || !fields.length) {\n          return false\n        }\n\n        possibleType.fields = [...fields]\n        return possibleType\n      }\n\n      return false\n    })\n    .filter(Boolean)\n\n  return possibleTypes && depth <= maxDepth ? transformedInlineFragments : null\n}\n\n// since we're counting circular types that may be on fields many levels up, incarnation felt like it works here ;) the types are born again in later generations\nconst countIncarnations = ({ typeName, ancestorTypeNames }) =>\n  ancestorTypeNames.length\n    ? ancestorTypeNames.filter(\n        (ancestorTypeName) => ancestorTypeName === typeName\n      )?.length\n    : 0\n\nexport function transformField({\n  field,\n  gatsbyNodesInfo,\n  typeMap,\n  maxDepth,\n  depth,\n  fieldBlacklist,\n  fieldAliases,\n  ancestorTypeNames: parentAncestorTypeNames,\n  circularQueryLimit,\n  fragments,\n  buildingFragment,\n  mainType,\n  parentField,\n} = {}) {\n  const ancestorTypeNames = [...parentAncestorTypeNames]\n\n  // we're potentially infinitely recursing when fields are connected to other types that have fields that are connections to other types\n  //  so we need a maximum limit for that\n  if (depth > maxDepth) {\n    return false\n  }\n\n  depth++\n\n  // if the field has no type we can't use it.\n  if (!field || !field.type) {\n    return false\n  }\n\n  const typeSettings = getTypeSettingsByType(field.type)\n\n  if (typeSettings.exclude) {\n    return false\n  }\n\n  // count the number of times this type has appeared as an ancestor of itself\n  // somewhere up the tree\n  const typeName = findTypeName(field.type)\n  const typeKind = findTypeKind(field.type)\n\n  const typeIncarnationCount = countIncarnations({\n    typeName,\n    ancestorTypeNames,\n  })\n\n  if (typeIncarnationCount > 0) {\n    // this type is nested within itself atleast once\n    // create a fragment here that can be reused\n    createFragment({\n      fields: typeMap.get(typeName).fields,\n      type: field.type,\n      fragments,\n      field,\n      ancestorTypeNames: parentAncestorTypeNames,\n      depth,\n      fieldBlacklist,\n      fieldAliases,\n      typeMap,\n      gatsbyNodesInfo,\n      circularQueryLimit,\n      queryDepth: maxDepth,\n      buildingFragment,\n      mainType,\n    })\n  }\n\n  if (typeIncarnationCount >= circularQueryLimit) {\n    return false\n  }\n\n  // this is used to alias fields that conflict with Gatsby node fields\n  // for ex Gatsby and WPGQL both have a `parent` field\n  const fieldName = returnAliasedFieldName({ fieldAliases, field })\n\n  if (\n    fieldBlacklist.includes(field.name) ||\n    fieldBlacklist.includes(fieldName)\n  ) {\n    return false\n  }\n\n  // remove fields that have required args. They'll cause query errors if ommitted\n  //  and we can't determine how to use those args programatically.\n  if (\n    field.args &&\n    field.args.length &&\n    field.args.find((arg) => arg?.type?.kind === `NON_NULL`)\n  ) {\n    return false\n  }\n\n  const fieldType = typeMap.get(findTypeName(field.type)) || {}\n  const ofType = typeMap.get(findTypeName(fieldType.ofType)) || {}\n\n  if (\n    fieldType.kind === `SCALAR` ||\n    fieldType.kind === `ENUM` ||\n    (fieldType.kind === `NON_NULL` && ofType.kind === `SCALAR`) ||\n    (fieldType.kind === `LIST` && fieldType.ofType.kind === `SCALAR`) ||\n    // a list of enums has no type name, so findTypeName above finds the enum type\n    // instead of the field type. Need to explicitly check here\n    // instead of using helpers\n    (field.type.kind === `LIST` && field.type?.ofType?.kind === `ENUM`)\n  ) {\n    return {\n      fieldName,\n      fieldType,\n    }\n  }\n\n  const isListOfGatsbyNodes =\n    ofType && gatsbyNodesInfo.typeNames.includes(typeName)\n\n  const isListOfMediaItems = ofType && typeName === `MediaItem`\n\n  const hasIdField = fieldType?.fields?.find(({ name }) => name === `id`)\n  if (\n    fieldType.kind === `LIST` &&\n    isListOfGatsbyNodes &&\n    !isListOfMediaItems &&\n    hasIdField\n  ) {\n    return {\n      fieldName: fieldName,\n      fields: [`id`],\n      fieldType,\n    }\n  } else if (fieldType.kind === `LIST` && isListOfMediaItems && hasIdField) {\n    return {\n      fieldName: fieldName,\n      fields: [`__typename`, `id`],\n      fieldType,\n    }\n  } else if (fieldType.kind === `LIST`) {\n    const listOfType = typeMap.get(findTypeName(fieldType))\n\n    const transformedFields = recursivelyTransformFields({\n      fields: listOfType.fields,\n      parentType: listOfType || fieldType,\n      depth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n      mainType,\n    })\n\n    const transformedInlineFragments = transformInlineFragments({\n      possibleTypes: listOfType.possibleTypes,\n      parentType: listOfType || fieldType,\n      parentField: field,\n      mainType,\n      gatsbyNodesInfo,\n      typeMap,\n      depth,\n      maxDepth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    if (!transformedFields?.length && !transformedInlineFragments?.length) {\n      return false\n    }\n\n    // if we have either inlineFragments or fields\n    return {\n      fieldName: fieldName,\n      fields: transformedFields,\n      inlineFragments: transformedInlineFragments,\n      fieldType,\n    }\n  }\n\n  const isAGatsbyNode =\n    // if this is a gatsby node type\n    gatsbyNodesInfo.typeNames.includes(typeName) ||\n    // or this type has a possible type which is a gatsby node type\n    typeMap\n      .get(typeName)\n      ?.possibleTypes?.find((possibleType) =>\n        gatsbyNodesInfo.typeNames.includes(possibleType.name)\n      )\n\n  const isAMediaItemNode = isAGatsbyNode && typeName === `MediaItem`\n\n  // pull the id and __typename for connections to media item gatsby nodes\n  if (isAMediaItemNode && hasIdField) {\n    return {\n      fieldName: fieldName,\n      fields: [`__typename`, `id`],\n      fieldType,\n    }\n  } else if (isAGatsbyNode && hasIdField) {\n    const isAnInterfaceType =\n      // if this is an interface\n      typeKind === `INTERFACE` || fieldType.kind === `INTERFACE`\n\n    return {\n      fieldName: fieldName,\n      fields: isAnInterfaceType\n        ? // we need the typename for interfaces\n          [`id`, `__typename`]\n        : // or just the id for 1:1 connections to gatsby nodes\n          [`id`],\n      fieldType,\n    }\n  }\n\n  const typeInfo = typeMap.get(findTypeName(fieldType))\n\n  const { fields } = typeInfo || {}\n\n  let transformedInlineFragments\n\n  if (typeInfo.possibleTypes) {\n    transformedInlineFragments = transformInlineFragments({\n      possibleTypes: typeInfo.possibleTypes,\n      parentType: typeInfo,\n      parentField: field,\n      mainType,\n      gatsbyNodesInfo,\n      typeMap,\n      depth,\n      maxDepth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n  }\n\n  if (fields || transformedInlineFragments) {\n    const transformedFields = recursivelyTransformFields({\n      parentType: typeInfo,\n      parentFieldName: field.name,\n      mainType,\n      fields,\n      depth,\n      ancestorTypeNames,\n      parentField: field,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    if (!transformedFields?.length && !transformedInlineFragments?.length) {\n      return false\n    }\n\n    return {\n      fieldName: fieldName,\n      fields: transformedFields,\n      inlineFragments: transformedInlineFragments,\n      fieldType,\n    }\n  }\n\n  if (fieldType.kind === `UNION`) {\n    const typeInfo = typeMap.get(fieldType.name)\n\n    const transformedFields = recursivelyTransformFields({\n      fields: typeInfo.fields,\n      parentType: fieldType,\n      mainType,\n      depth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    const inlineFragments = transformInlineFragments({\n      possibleTypes: typeInfo.possibleTypes,\n      gatsbyNodesInfo,\n      typeMap,\n      mainType,\n      depth,\n      maxDepth,\n      ancestorTypeNames,\n      parentField: field,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    return {\n      fieldName: fieldName,\n      fields: transformedFields,\n      inlineFragments,\n      fieldType,\n    }\n  }\n\n  return false\n}\n\nconst createFragment = ({\n  fields,\n  field,\n  type,\n  fragments,\n  fieldBlacklist,\n  fieldAliases,\n  typeMap,\n  gatsbyNodesInfo,\n  queryDepth,\n  ancestorTypeNames,\n  mainType,\n  buildingFragment = false,\n}) => {\n  const typeName = findTypeName(type)\n\n  if (buildingFragment) {\n    // this fragment is inside a fragment that's already being built so we should exit\n    return null\n  }\n\n  const previouslyCreatedFragment = fragments?.[typeName]\n\n  if (previouslyCreatedFragment && buildingFragment === typeName) {\n    return previouslyCreatedFragment\n  }\n\n  const fragmentFields = fields.reduce((fragmentFields, field) => {\n    const fieldTypeName = findTypeName(field.type)\n    const fieldType = typeMap.get(fieldTypeName)\n\n    if (\n      // if this field is a different type than the fragment but has a field of the same type as the fragment,\n      // we need to skip this field in the fragment to prevent nesting this type in itself a level down\n      fieldType.name !== typeName &&\n      fieldType?.fields?.find(\n        (innerFieldField) => findTypeName(innerFieldField.type) === typeName\n      )\n    ) {\n      return fragmentFields\n    }\n\n    const transformedField = transformField({\n      field,\n      gatsbyNodesInfo,\n      typeMap,\n      maxDepth: queryDepth,\n      depth: 0,\n      fieldBlacklist,\n      fieldAliases,\n      ancestorTypeNames,\n      mainType,\n      circularQueryLimit: 1,\n      fragments,\n      buildingFragment: typeName,\n    })\n\n    if (findTypeName(field.type) !== typeName && !!transformedField) {\n      fragmentFields.push(transformedField)\n    }\n\n    return fragmentFields\n  }, [])\n\n  const queryType = typeMap.get(typeName)\n\n  const transformedInlineFragments = queryType?.possibleTypes?.length\n    ? transformInlineFragments({\n        possibleTypes: queryType.possibleTypes,\n        parentType: queryType,\n        parentField: field,\n        mainType,\n        gatsbyNodesInfo,\n        typeMap,\n        depth: 0,\n        maxDepth: queryDepth,\n        circularQueryLimit: 1,\n        ancestorTypeNames,\n        fragments,\n        buildingFragment: typeName,\n      })\n    : null\n\n  if (fragments) {\n    fragments[typeName] = {\n      name: `${typeName}Fragment`,\n      type: typeName,\n      fields: fragmentFields,\n      inlineFragments: transformedInlineFragments,\n    }\n  }\n\n  return fragmentFields\n}\n\nconst transformFields = ({\n  fields,\n  parentType,\n  mainType,\n  fragments,\n  parentField,\n  ancestorTypeNames,\n  depth,\n  fieldBlacklist,\n  fieldAliases,\n  typeMap,\n  gatsbyNodesInfo,\n  queryDepth,\n  circularQueryLimit,\n  pluginOptions,\n  buildingFragment,\n}) =>\n  fields\n    ?.filter(\n      (field) =>\n        !fieldIsExcludedOnParentType({\n          pluginOptions,\n          field,\n          parentType,\n          mainType,\n          parentField,\n        })\n    )\n    .map((field) => {\n      const transformedField = transformField({\n        maxDepth: queryDepth,\n        gatsbyNodesInfo,\n        fieldBlacklist,\n        fieldAliases,\n        typeMap,\n        field,\n        depth,\n        ancestorTypeNames,\n        circularQueryLimit,\n        fragments,\n        buildingFragment,\n        mainType,\n        parentField,\n      })\n\n      if (transformedField) {\n        // save this type so we know to use it in schema customization\n        store.dispatch.remoteSchema.addFetchedType(field.type)\n      }\n\n      const typeName = findTypeName(field.type)\n      const fragment = fragments?.[typeName]\n\n      // @todo add any adjacent fields and inline fragments directly to the stored fragment object so this logic can be changed to if (fragment) useTheFragment()\n      // once that's done it can be added above and below transformField() above ☝️\n      // and potentially short circuit expensive work that will be thrown away anyway\n      if (fragment && transformedField && buildingFragment !== typeName) {\n        // if (fragment && buildingFragment !== typeName && transformedField) {\n        // remove fields from this query that already exist in the fragment\n        if (transformedField?.fields?.length) {\n          transformedField.fields = transformedField.fields.filter(\n            (field) =>\n              !fragment.fields.find(\n                (fragmentField) => fragmentField.fieldName === field.fieldName\n              )\n          )\n        }\n\n        // if this field has no fields (because it has inline fragments only)\n        // we need to create an empty array since we treat reusable fragments as\n        // a field\n        if (!transformedField.fields) {\n          transformedField.fields = []\n        }\n\n        transformedField.fields.push({\n          internalType: `Fragment`,\n          fragment,\n        })\n\n        if (transformedField?.inlineFragments?.length) {\n          transformedField.inlineFragments = transformedField.inlineFragments.filter(\n            (fieldInlineFragment) =>\n              // yes this is a horrible use of .find(). @todo refactor this for better perf\n              !fragment.inlineFragments.find(\n                (fragmentInlineFragment) =>\n                  fragmentInlineFragment.name === fieldInlineFragment.name\n              )\n          )\n        }\n      }\n\n      if (field.fields && !transformedField) {\n        return null\n      }\n\n      const fieldTypeKind = findTypeKind(field.type)\n      const fieldOfTypeKind = findTypeKind(field.type.ofType)\n      const typeKindsRequiringSelectionSets = [`OBJECT`, `UNION`, `INTERFACE`]\n      const fieldNeedsSelectionSet =\n        typeKindsRequiringSelectionSets.includes(fieldTypeKind) ||\n        typeKindsRequiringSelectionSets.includes(fieldOfTypeKind)\n\n      if (\n        // if our field needs a selectionset\n        fieldNeedsSelectionSet &&\n        // but we have no fields\n        !transformedField.fields &&\n        // and no inline fragments\n        !transformedField.inlineFragments\n      ) {\n        // we need to discard this field to prevent GraphQL errors\n        // we're likely at the very bottom of the query depth\n        // so that this fields children were omitted\n        return null\n      }\n\n      return transformedField\n    })\n    .filter(Boolean)\n\nconst recursivelyTransformFields = ({\n  fields,\n  parentType,\n  mainType,\n  fragments,\n  parentField,\n  ancestorTypeNames: parentAncestorTypeNames,\n  depth = 0,\n  buildingFragment = false,\n}) => {\n  if (!fields || !fields.length) {\n    return null\n  }\n\n  if (!parentAncestorTypeNames) {\n    parentAncestorTypeNames = []\n  }\n\n  const ancestorTypeNames = [...parentAncestorTypeNames]\n\n  const {\n    gatsbyApi: { pluginOptions },\n    remoteSchema: { fieldBlacklist, fieldAliases, typeMap, gatsbyNodesInfo },\n  } = store.getState()\n\n  const {\n    schema: { queryDepth, circularQueryLimit },\n  } = pluginOptions\n\n  if (depth > queryDepth && ancestorTypeNames.length) {\n    return null\n  }\n\n  const typeName = findTypeName(parentType)\n\n  const grandParentTypeName = ancestorTypeNames.length\n    ? ancestorTypeNames[ancestorTypeNames.length - 1]\n    : null\n\n  if (grandParentTypeName && typeName !== grandParentTypeName) {\n    // if a field has fields of the same type as the field above it\n    // we shouldn't fetch them. 2 types that are circular between each other\n    // are dangerous as they will generate very large queries and fetch data we don't need\n    // these types should instead be proper connections so we can identify\n    // that only an id needs to be fetched.\n    // @todo maybe move this into transformFields() instead of here\n    fields = fields.filter((field) => {\n      const fieldTypeName = findTypeName(field.type)\n      return fieldTypeName !== grandParentTypeName\n    })\n  }\n\n  const typeIncarnationCount = countIncarnations({\n    typeName,\n    ancestorTypeNames,\n  })\n\n  if (typeIncarnationCount >= circularQueryLimit) {\n    return null\n  }\n\n  parentAncestorTypeNames.push(typeName)\n\n  const recursivelyTransformedFields = transformFields({\n    fields,\n    parentType,\n    mainType,\n    fragments,\n    parentField,\n    ancestorTypeNames: parentAncestorTypeNames,\n    depth,\n    fieldBlacklist,\n    fieldAliases,\n    typeMap,\n    gatsbyNodesInfo,\n    queryDepth,\n    circularQueryLimit,\n    pluginOptions,\n    buildingFragment,\n  })\n\n  if (!recursivelyTransformedFields.length) {\n    return null\n  }\n\n  return recursivelyTransformedFields\n}\n\nexport default recursivelyTransformFields\n"],"file":"recursively-transform-fields.js"}