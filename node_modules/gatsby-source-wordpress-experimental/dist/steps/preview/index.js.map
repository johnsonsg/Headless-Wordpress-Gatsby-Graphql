{"version":3,"sources":["../../../src/steps/preview/index.ts"],"names":["inPreviewMode","process","env","ENABLE_GATSBY_REFRESH_ENDPOINT","store","getState","previewStore","previewQueue","getPreviewQueue","previewRequestConcurrency","gatsbyApi","pluginOptions","schema","PQueue","concurrency","carryoverConcurrencyCount","sourcePreviews","webhookBody","reporter","debug","preview","inPreviewDebugMode","info","previewForIdIsAlreadyBeingProcessed","id","previewActions","contentTypePlural","nodeTypeName","headers","WPGatsbyPreview","token","WPGatsbyPreviewUser","userDatabaseId","query","Date","now","length","queue","forEach","previewData","add","sourcePreview","Promise","all","onEmpty","onIdle","url","requiredProperties","missingProperties","filter","property","warn","JSON","stringify","log","hostname","settingsHostname","urlUtil","parse","remoteHostname","remoteUrl","sendPreviewStatus","createPreviewStatusCallback","status","context","passedNode","modified","databaseId","parentDatabaseId","graphqlEndpoint","chalk","bold","dispatch","setInPreviewMode","subscribeToPagesCreatedFromNodeById","nodeId","actionType","previewParentId","isPreview","pageNode","error","writeDummyPageDataJsonIfNeeded","statusContext","message","data","variables","input","clientMutationId","pagePath","path","previewDatabaseId","errorContext","forceReportCriticalErrors","wpGatsbyRemotePreviewStatus","success","isDraft","pageDataDirectory","join","cwd","fs","ensureDir","pageDataPath","pageDataExists","exists","writeJSON","existingCallbacks","nodePageCreatedCallbacks","alreadyProcessingThisPreview"],"mappings":"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","sourcesContent":["import { getPluginOptions } from \"./../../utils/get-gatsby-api\"\nimport { GatsbyHelpers } from \"~/utils/gatsby-types\"\nimport path from \"path\"\nimport fs from \"fs-extra\"\nimport chalk from \"chalk\"\nimport urlUtil from \"url\"\nimport PQueue from \"p-queue\"\nimport { dump } from \"dumper.js\"\n\nimport { paginatedWpNodeFetch } from \"~/steps/source-nodes/fetch-nodes/fetch-nodes-paginated\"\nimport fetchGraphql from \"~/utils/fetch-graphql\"\n\nimport store from \"~/store\"\n\nimport { fetchAndCreateSingleNode } from \"~/steps/source-nodes/update-nodes/wp-actions/update\"\nimport { formatLogMessage } from \"~/utils/format-log-message\"\nimport { touchValidNodes } from \"../source-nodes/update-nodes/fetch-node-updates\"\n\nimport { IPluginOptions } from \"~/models/gatsby-api\"\nimport { Reporter } from \"gatsby\"\n\nexport const inPreviewMode = (): boolean =>\n  !!process.env.ENABLE_GATSBY_REFRESH_ENDPOINT &&\n  !!store.getState().previewStore.inPreviewMode\n\nexport type PreviewStatusUnion =\n  | `PREVIEW_SUCCESS`\n  | `NO_PAGE_CREATED_FOR_PREVIEWED_NODE`\n  | `GATSBY_PREVIEW_PROCESS_ERROR`\n  | `RECEIVED_PREVIEW_DATA_FROM_WRONG_URL`\n\nexport interface IWebhookBody {\n  previewDatabaseId: number\n  userDatabaseId: number\n  token: string\n  remoteUrl: string\n  modified: string\n  parentDatabaseId: number\n  id: string\n  isDraft: boolean\n  singleName: string\n}\n\ninterface IPageNode {\n  path: string\n}\n\nlet previewQueue: PQueue\n\nconst getPreviewQueue = (): PQueue => {\n  if (!previewQueue) {\n    const {\n      previewRequestConcurrency,\n    } = store.getState().gatsbyApi.pluginOptions.schema\n\n    previewQueue = new PQueue({\n      concurrency: previewRequestConcurrency,\n      carryoverConcurrencyCount: true,\n    })\n  }\n\n  return previewQueue\n}\n\n/**\n * This is called when the /__refresh endpoint is posted to from WP previews.\n * It should only ever run in Preview mode, which is process.env.ENABLE_GATSBY_REFRESH_ENDPOINT = true\n * It first sources all pending preview actions, then calls sourcePreview() for each of them.\n */\nexport const sourcePreviews = async (\n  { webhookBody, reporter }: GatsbyHelpers,\n  pluginOptions: IPluginOptions\n): Promise<void> => {\n  const {\n    debug: { preview: inPreviewDebugMode },\n  } = getPluginOptions()\n\n  if (inPreviewDebugMode) {\n    reporter.info(`Sourcing previews for the following webhook:`)\n    dump(webhookBody)\n  }\n\n  if (previewForIdIsAlreadyBeingProcessed(webhookBody?.id)) {\n    if (inPreviewDebugMode) {\n      reporter.info(\n        `Preview for id ${webhookBody?.id} is already being sourced.`\n      )\n    }\n    return\n  }\n\n  const previewActions = await paginatedWpNodeFetch({\n    contentTypePlural: `actionMonitorActions`,\n    nodeTypeName: `ActionMonitor`,\n    headers: {\n      WPGatsbyPreview: webhookBody.token,\n      WPGatsbyPreviewUser: webhookBody.userDatabaseId,\n    },\n    query: /* GraphQL */ `\n      query PREVIEW_ACTIONS($after: String) {\n        actionMonitorActions(\n          where: {\n            previewStream: true\n            status: PRIVATE\n            orderby: { field: MODIFIED, order: DESC }\n            sinceTimestamp: ${\n              // only source previews made in the last 10 minutes\n              Date.now() - 1000 * 60 * 10\n            }\n          }\n          first: 100\n          after: $after\n        ) {\n          nodes {\n            previewData {\n              id\n              isDraft\n              modified\n              parentDatabaseId\n              previewDatabaseId\n              remoteUrl\n              singleName\n              userDatabaseId\n            }\n          }\n          pageInfo {\n            hasNextPage\n            endCursor\n          }\n        }\n      }\n    `,\n  })\n\n  if (!previewActions?.length) {\n    if (inPreviewDebugMode) {\n      reporter.info(\n        `Preview for id ${webhookBody?.id} returned no action monitor actions.`\n      )\n    }\n    return\n  }\n\n  if (inPreviewDebugMode) {\n    reporter.info(\n      `Preview for id ${webhookBody?.id} returned the following actions:`\n    )\n    dump(previewActions)\n  }\n\n  const queue = getPreviewQueue()\n\n  previewActions?.forEach(({ previewData }) => {\n    queue.add(() =>\n      sourcePreview(\n        {\n          previewData: { ...previewData, token: webhookBody.token },\n          reporter,\n        },\n        pluginOptions\n      )\n    )\n  })\n\n  await Promise.all([queue.onEmpty(), queue.onIdle()])\n}\n\n/**\n * This is called and passed the result from the ActionMonitor.previewData object along with a JWT token\n * It sources a single preview and creates the callback that's invoked to send preview status back to WPGatsby.\n * When the preview status is sent back to Gatsby, the preview action that this\n * logic is processing is deleted in the WP instance. That's why we call\n * previewForIdIsAlreadyBeingProcessed to see if another preview webhook\n * already started processing for this action\n */\nexport const sourcePreview = async (\n  { previewData, reporter }: { previewData: IWebhookBody; reporter: Reporter },\n  { url }: IPluginOptions\n): Promise<void> => {\n  if (previewForIdIsAlreadyBeingProcessed(previewData?.id)) {\n    return\n  }\n\n  const requiredProperties = [\n    `previewDatabaseId`,\n    `id`,\n    `token`,\n    `remoteUrl`,\n    `parentDatabaseId`,\n    `modified`,\n    `userDatabaseId`,\n  ]\n\n  const missingProperties = requiredProperties.filter(\n    (property) => !(property in previewData)\n  )\n\n  if (!previewData || missingProperties.length) {\n    reporter.warn(\n      formatLogMessage(\n        `sourcePreview was called but the required previewData properties weren't provided.`\n      )\n    )\n    reporter.info(\n      formatLogMessage(\n        `Missing properties: \\n${JSON.stringify(missingProperties, null, 2)}`\n      )\n    )\n    reporter.log(\n      formatLogMessage(`previewData: \\n${JSON.stringify(previewData, null, 2)}`)\n    )\n    return\n  }\n\n  await touchValidNodes()\n\n  const { hostname: settingsHostname } = urlUtil.parse(url)\n  const { hostname: remoteHostname } = urlUtil.parse(previewData.remoteUrl)\n\n  const sendPreviewStatus = createPreviewStatusCallback({\n    previewData,\n    reporter,\n  })\n\n  if (settingsHostname !== remoteHostname) {\n    await sendPreviewStatus({\n      status: `RECEIVED_PREVIEW_DATA_FROM_WRONG_URL`,\n      context: `check that the preview data came from the right URL.`,\n      passedNode: {\n        modified: previewData.modified,\n        databaseId: previewData.parentDatabaseId,\n      },\n      graphqlEndpoint: previewData.remoteUrl,\n    })\n\n    reporter.warn(\n      formatLogMessage(\n        `Received preview data from a different remote URL than the one specified in plugin options. \\n\\n ${chalk.bold(\n          `Remote URL:`\n        )} ${previewData.remoteUrl}\\n ${chalk.bold(\n          `Plugin options URL:`\n        )} ${url}`\n      )\n    )\n\n    return\n  }\n\n  store.dispatch.previewStore.setInPreviewMode(true)\n\n  // this callback will be invoked when the page is created/updated for this node\n  // then it'll send a mutation to WPGraphQL so that WP knows the preview is ready\n  store.dispatch.previewStore.subscribeToPagesCreatedFromNodeById({\n    nodeId: previewData.id,\n    modified: previewData.modified,\n    sendPreviewStatus,\n  })\n\n  await fetchAndCreateSingleNode({\n    actionType: `PREVIEW`,\n    ...previewData,\n    previewParentId: previewData.parentDatabaseId,\n    isPreview: true,\n  })\n}\n\ninterface OnPreviewStatusInput {\n  status: PreviewStatusUnion\n  context?: string\n  nodeId?: string\n  passedNode?: {\n    modified?: string\n    databaseId: number\n  }\n  pageNode?: IPageNode\n  graphqlEndpoint?: string\n  error?: Error\n}\n\nconst createPreviewStatusCallback = ({\n  previewData,\n  reporter,\n}: {\n  previewData: IWebhookBody\n  reporter: Reporter\n}) => async ({\n  passedNode,\n  pageNode,\n  context,\n  status,\n  graphqlEndpoint,\n  error,\n}: OnPreviewStatusInput): Promise<void> => {\n  if (status === `PREVIEW_SUCCESS`) {\n    // we might need to write a dummy page-data.json so that\n    // Gatsby doesn't throw 404 errors when WPGatsby tries to read this file\n    // that maybe doesn't exist yet\n    await writeDummyPageDataJsonIfNeeded({ previewData, pageNode })\n  }\n\n  const statusContext = error?.message\n    ? `${context}\\n\\n${error.message}`\n    : context\n\n  const { data } = await fetchGraphql({\n    url: graphqlEndpoint,\n    query: /* GraphQL */ `\n      mutation MUTATE_PREVIEW_NODE($input: WpGatsbyRemotePreviewStatusInput!) {\n        wpGatsbyRemotePreviewStatus(input: $input) {\n          success\n        }\n      }\n    `,\n    variables: {\n      input: {\n        clientMutationId: `sendPreviewStatus`,\n        modified: passedNode?.modified,\n        pagePath: pageNode?.path,\n        parentDatabaseId:\n          previewData.parentDatabaseId || previewData.previewDatabaseId, // if the parentDatabaseId is 0 we want to use the previewDatabaseId\n        status,\n        statusContext,\n      },\n    },\n    errorContext: `Error occurred while mutating WordPress Preview node meta.`,\n    forceReportCriticalErrors: true,\n    headers: {\n      WPGatsbyPreview: previewData.token,\n      WPGatsbyPreviewUser: previewData.userDatabaseId,\n    },\n  })\n\n  if (data?.wpGatsbyRemotePreviewStatus?.success) {\n    reporter.log(\n      formatLogMessage(\n        `Successfully sent Preview status back to WordPress post ${previewData.id} during ${context}`\n      )\n    )\n  } else {\n    reporter.log(\n      formatLogMessage(\n        `failed to mutate WordPress post ${previewData.id} during Preview ${context}.\\nCheck your WP server logs for more information.`\n      )\n    )\n  }\n}\n\n/**\n * For previews of draft posts, gatsby develop will throw a bunch of 404 errors\n * while WPGatsby is trying to read page-data.json\n * So we can write a dummy page-data.json if one doesn't exist.\n * that way there will be no 404's and Gatsby will overwrite our dummy file when it\n * needs to.\n */\nconst writeDummyPageDataJsonIfNeeded = async ({\n  previewData,\n  pageNode,\n}: {\n  previewData: IWebhookBody\n  pageNode: IPageNode\n}): Promise<void> => {\n  if (!previewData.isDraft) {\n    return\n  }\n\n  const pageDataDirectory = path.join(\n    process.cwd(),\n    `public/page-data`,\n    pageNode.path\n  )\n\n  await fs.ensureDir(pageDataDirectory)\n\n  const pageDataPath = path.join(pageDataDirectory, `page-data.json`)\n\n  const pageDataExists = await fs.exists(pageDataPath)\n\n  if (!pageDataExists) {\n    await fs.writeJSON(pageDataPath, {\n      isDraft: previewData.isDraft,\n    })\n  }\n}\n\n// This checks wether or not we're already currently processing a preview\n// for the passed preview id.\nconst previewForIdIsAlreadyBeingProcessed = (id: string): boolean => {\n  if (!id) {\n    return false\n  }\n\n  const existingCallbacks = store.getState().previewStore\n    .nodePageCreatedCallbacks\n\n  const alreadyProcessingThisPreview = !!existingCallbacks?.[id]\n\n  return alreadyProcessingThisPreview\n}\n"],"file":"index.js"}