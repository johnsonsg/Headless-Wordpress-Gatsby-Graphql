{"version":3,"sources":["../../../src/steps/create-schema-customization/build-types.js"],"names":["unionType","typeBuilderApi","typeDefs","schema","type","pluginOptions","types","possibleTypes","filter","possibleType","typeName","name","map","length","resolveType","node","__typename","extensions","infer","push","buildUnionType","interfaceType","gatsbyNodeTypes","fieldAliases","fieldBlacklist","state","store","getState","ingestibles","typeMap","remoteSchema","nodeInterfaceTypes","allTypes","values","implementingTypes","Array","from","interfaces","find","singleInterface","get","kind","transformedFields","parentInterfacesImplementingTypes","fields","typeDef","includes","nodeInterface","buildInterfaceType","objectType","isAGatsbyNode","parentType","Object","keys","description","interfaceTypeSettings","exclude","buildObjectType","enumType","buildEnumType","enumValues","reduce","accumulator"],"mappings":"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","sourcesContent":["import store from \"~/store\"\nimport { transformFields } from \"./transform-fields\"\nimport { typeIsExcluded } from \"~/steps/ingest-remote-schema/is-excluded\"\nimport {\n  buildTypeName,\n  fieldOfTypeWasFetched,\n  getTypeSettingsByType,\n  filterTypeDefinition,\n} from \"./helpers\"\n\nconst unionType = (typeBuilderApi) => {\n  const { typeDefs, schema, type, pluginOptions } = typeBuilderApi\n\n  const types = type.possibleTypes\n    .filter(\n      (possibleType) =>\n        !typeIsExcluded({\n          pluginOptions,\n          typeName: possibleType.name,\n        })\n    )\n    .map((possibleType) => buildTypeName(possibleType.name))\n\n  if (!types || !types.length) {\n    return\n  }\n\n  let unionType = {\n    name: buildTypeName(type.name),\n    types,\n    resolveType: (node) => {\n      if (node.type) {\n        return buildTypeName(node.type)\n      }\n\n      if (node.__typename) {\n        return buildTypeName(node.__typename)\n      }\n\n      return null\n    },\n    extensions: {\n      infer: false,\n    },\n  }\n\n  // @todo add this as a plugin option\n  unionType = filterTypeDefinition(unionType, typeBuilderApi, `UNION`)\n\n  typeDefs.push(schema.buildUnionType(unionType))\n}\n\nconst interfaceType = (typeBuilderApi) => {\n  const {\n    type,\n    typeDefs,\n    schema,\n    gatsbyNodeTypes,\n    fieldAliases,\n    fieldBlacklist,\n  } = typeBuilderApi\n\n  const state = store.getState()\n  const { ingestibles, typeMap } = state.remoteSchema\n  const { nodeInterfaceTypes } = ingestibles\n\n  const allTypes = typeMap.values()\n\n  const implementingTypes = Array.from(allTypes)\n    .filter(\n      ({ interfaces }) =>\n        interfaces &&\n        // find types that implement this interface type\n        interfaces.find((singleInterface) => singleInterface.name === type.name)\n    )\n    .map((type) => typeMap.get(type.name))\n    .filter(\n      (type) =>\n        type.kind !== `UNION` ||\n        // if this is a union type, make sure the union type has one or more member types, otherwise schema customization will throw an error\n        (!!type.possibleTypes && !!type.possibleTypes.length)\n    )\n\n  const transformedFields = transformFields({\n    parentInterfacesImplementingTypes: implementingTypes,\n    fields: type.fields,\n    gatsbyNodeTypes,\n    fieldAliases,\n    fieldBlacklist,\n  })\n\n  let typeDef = {\n    name: buildTypeName(type.name),\n    fields: transformedFields,\n    extensions: { infer: false },\n  }\n\n  // if this is a node interface type\n  if (nodeInterfaceTypes.includes(type.name)) {\n    // we add nodeType (post type) to all nodes as they're fetched\n    // so we can add them to node interfaces as well in order to filter\n    // by a couple different content types\n    typeDef.fields[`nodeType`] = `String`\n    typeDef.extensions.nodeInterface = {}\n  } else {\n    // otherwise this is a regular interface type so we need to resolve the type name\n    typeDef.resolveType = (node) =>\n      node && node.__typename ? buildTypeName(node.__typename) : null\n  }\n\n  // @todo add this as a plugin option\n  typeDef = filterTypeDefinition(typeDef, typeBuilderApi, `INTERFACE`)\n\n  typeDefs.push(schema.buildInterfaceType(typeDef))\n}\n\nconst objectType = (typeBuilderApi) => {\n  const {\n    type,\n    gatsbyNodeTypes,\n    fieldAliases,\n    fieldBlacklist,\n    typeDefs,\n    schema,\n    isAGatsbyNode,\n  } = typeBuilderApi\n\n  const transformedFields = transformFields({\n    fields: type.fields,\n    parentType: type,\n    gatsbyNodeTypes,\n    fieldAliases,\n    fieldBlacklist,\n  })\n\n  // if all child fields are excluded, this type shouldn't exist.\n  if (!Object.keys(transformedFields).length) {\n    return\n  }\n\n  let objectType = {\n    name: buildTypeName(type.name),\n    fields: transformedFields,\n    description: type.description,\n    extensions: {\n      infer: false,\n    },\n  }\n\n  if (type.interfaces) {\n    objectType.interfaces = type.interfaces\n      .filter((interfaceType) => {\n        const interfaceTypeSettings = getTypeSettingsByType(interfaceType)\n\n        return !interfaceTypeSettings.exclude && fieldOfTypeWasFetched(type)\n      })\n      .map(({ name }) => buildTypeName(name))\n  }\n\n  if (\n    gatsbyNodeTypes.includes(type.name) ||\n    isAGatsbyNode ||\n    // this accounts for Node types that weren't fetched because\n    // they have no root field to fetch a single node of this type\n    // removing them from the schema breaks the build though\n    // @todo instead, if a node type isn't fetched, remove it\n    // from the entire schema\n    type?.interfaces?.find(({ name }) => name === `Node`)\n  ) {\n    // this is used to filter the node interfaces\n    // by different content types (post types)\n    objectType.fields[`nodeType`] = `String`\n\n    objectType.interfaces = [`Node`, ...objectType.interfaces]\n  }\n\n  // @todo add this as a plugin option\n  objectType = filterTypeDefinition(objectType, typeBuilderApi, `OBJECT`)\n\n  typeDefs.push(schema.buildObjectType(objectType))\n}\n\nconst enumType = ({ typeDefs, schema, type }) => {\n  typeDefs.push(\n    schema.buildEnumType({\n      name: buildTypeName(type.name),\n      values: type.enumValues.reduce((accumulator, { name }) => {\n        accumulator[name] = { name }\n\n        return accumulator\n      }, {}),\n      description: type.description,\n    })\n  )\n}\n\nexport default { unionType, interfaceType, objectType, enumType }\n"],"file":"build-types.js"}