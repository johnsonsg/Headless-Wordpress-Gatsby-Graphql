{"version":3,"sources":["../../../../../src/steps/source-nodes/create-nodes/create-remote-file-node/index.js"],"names":["fs","require","remoteFileDownloaderBarPromise","got","createContentDigest","path","isWebUri","Queue","readChunk","fileType","createProgress","createFileNode","getRemoteFileExtension","getRemoteFileName","createFilePath","cacheId","url","bar","totalJobs","STALL_RETRY_LIMIT","STALL_TIMEOUT","CONNECTION_RETRY_LIMIT","CONNECTION_TIMEOUT","queue","getQueue","limit","pushToQueue","id","merge","old","_","cb","concurrent","on","awaitingCreateRemoteFileNodePromise","doneQueueTimeout","setTimeout","done","task","node","processRemoteNode","e","requestRemoteNode","headers","tmpFilename","httpOpts","attempt","Promise","resolve","reject","timeout","handleTimeout","fsWriteStream","close","removeSync","processingCache","total","Error","resetTimeout","clearTimeout","responseStream","stream","retries","createWriteStream","pipe","error","console","response","cache","createNode","parentNodeId","auth","httpHeaders","createNodeId","ext","name","pluginCacheDir","directory","cachedHeaders","get","etag","htaccess_pass","htaccess_user","digest","statusCode","set","buffer","sync","minimumBytes","filetype","filename","join","String","move","overwrite","remove","fileNode","internal","description","parent","pushTask","push","err","module","exports","getCache","reporter","pluginOptions","type","MediaItem","localFile","requestConcurrency","decodeURI","encodeURI","undefined","start","fileDownloadPromise","then","tick"],"mappings":"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","sourcesContent":["const fs = require(`fs-extra`)\nimport btoa from \"btoa\"\nconst { remoteFileDownloaderBarPromise } = require(`./progress-bar-promise`)\nconst got = require(`got`)\nconst { createContentDigest } = require(`gatsby-core-utils`)\nconst path = require(`path`)\nconst { isWebUri } = require(`valid-url`)\nconst Queue = require(`better-queue`)\nconst readChunk = require(`read-chunk`)\nconst fileType = require(`file-type`)\nconst { createProgress } = require(`gatsby-source-filesystem/utils`)\n\nconst { createFileNode } = require(`gatsby-source-filesystem/create-file-node`)\nconst {\n  getRemoteFileExtension,\n  getRemoteFileName,\n  createFilePath,\n} = require(`gatsby-source-filesystem/utils`)\nconst cacheId = (url) => `create-remote-file-node-${url}`\n\nlet bar\n// Keep track of the total number of jobs we push in the queue\nlet totalJobs = 0\n\n/** ******************\n * Type Definitions *\n ********************/\n\n/**\n * @typedef {GatsbyCache}\n * @see gatsby/packages/gatsby/utils/cache.js\n */\n\n/**\n * @typedef {Reporter}\n * @see gatsby/packages/gatsby-cli/lib/reporter.js\n */\n\n/**\n * @typedef {Auth}\n * @type {Object}\n * @property {String} htaccess_pass\n * @property {String} htaccess_user\n */\n\n/**\n * @typedef {CreateRemoteFileNodePayload}\n * @typedef {Object}\n * @description Create Remote File Node Payload\n *\n * @param  {String} options.url\n * @param  {GatsbyCache} options.cache\n * @param  {Function} options.createNode\n * @param  {Function} options.getCache\n * @param  {Auth} [options.auth]\n * @param  {Reporter} [options.reporter]\n */\n\nconst STALL_RETRY_LIMIT = 3\nconst STALL_TIMEOUT = 30000\n\nconst CONNECTION_RETRY_LIMIT = 5\nconst CONNECTION_TIMEOUT = 30000\n\n/** ******************\n * Queue Management *\n ********************/\n\n/**\n * Queue\n * Use the task's url as the id\n * When pushing a task with a similar id, prefer the original task\n * as it's already in the processing cache\n */\n\nlet queue = null\n\nconst getQueue = (limit) => {\n  if (!queue) {\n    queue = new Queue(pushToQueue, {\n      id: `url`,\n      merge: (old, _, cb) => cb(old),\n      concurrent: limit || 100,\n    })\n    // when the queue is empty we stop the progressbar\n    queue.on(`drain`, async () => {\n      if (awaitingCreateRemoteFileNodePromise) {\n        return\n      }\n\n      awaitingCreateRemoteFileNodePromise = true\n      await remoteFileDownloaderBarPromise\n      awaitingCreateRemoteFileNodePromise = false\n\n      if (bar) {\n        // this is to give us a little time to wait and see if there\n        // will be more jobs added with a break between\n        // sometimes the queue empties but then is recreated within 2 secs\n        doneQueueTimeout = setTimeout(() => {\n          bar.done()\n          totalJobs = 0\n        }, 2000)\n      }\n    })\n  }\n  return queue\n}\n\nlet doneQueueTimeout\n\nlet awaitingCreateRemoteFileNodePromise\n\n/**\n * @callback {Queue~queueCallback}\n * @param {*} error\n * @param {*} result\n */\n\n/**\n * pushToQueue\n * --\n * Handle tasks that are pushed in to the Queue\n *\n *\n * @param  {CreateRemoteFileNodePayload}          task\n * @param  {Queue~queueCallback}  cb\n * @return {Promise<null>}\n */\nasync function pushToQueue(task, cb) {\n  try {\n    const node = await processRemoteNode(task)\n    return cb(null, node)\n  } catch (e) {\n    return cb(e)\n  }\n}\n\n/** ****************\n * Core Functions *\n ******************/\n\n/**\n * requestRemoteNode\n * --\n * Download the requested file\n *\n * @param  {String}   url\n * @param  {Headers}  headers\n * @param  {String}   tmpFilename\n * @param  {Object}   httpOpts\n * @param  {number}   attempt\n * @return {Promise<Object>}  Resolves with the [http Result Object]{@link https://nodejs.org/api/http.html#http_class_http_serverresponse}\n */\nconst requestRemoteNode = (url, headers, tmpFilename, httpOpts, attempt = 1) =>\n  new Promise((resolve, reject) => {\n    let timeout\n\n    // Called if we stall for 30s without receiving any data\n    const handleTimeout = async () => {\n      fsWriteStream.close()\n      fs.removeSync(tmpFilename)\n      if (attempt < STALL_RETRY_LIMIT) {\n        // Retry by calling ourself recursively\n        resolve(\n          requestRemoteNode(url, headers, tmpFilename, httpOpts, attempt + 1)\n        )\n      } else {\n        processingCache[url] = null\n        totalJobs -= 1\n        bar.total = totalJobs\n        reject(\n          new Error(\n            `Failed to download ${url} after ${STALL_RETRY_LIMIT} attempts`\n          )\n        )\n      }\n    }\n\n    const resetTimeout = () => {\n      if (timeout) {\n        clearTimeout(timeout)\n      }\n      timeout = setTimeout(handleTimeout, STALL_TIMEOUT)\n    }\n\n    const responseStream = got.stream(url, {\n      headers,\n      timeout: CONNECTION_TIMEOUT,\n      retries: CONNECTION_RETRY_LIMIT,\n      ...httpOpts,\n    })\n    const fsWriteStream = fs.createWriteStream(tmpFilename)\n    responseStream.pipe(fsWriteStream)\n\n    // If there's a 400/500 response or other error.\n    responseStream.on(`error`, (error) => {\n      if (timeout) {\n        clearTimeout(timeout)\n      }\n      processingCache[url] = null\n      totalJobs -= 1\n      bar.total = totalJobs\n      fs.removeSync(tmpFilename)\n      console.error(error)\n      reject(error)\n    })\n\n    fsWriteStream.on(`error`, (error) => {\n      if (timeout) {\n        clearTimeout(timeout)\n      }\n      processingCache[url] = null\n      totalJobs -= 1\n      bar.total = totalJobs\n      reject(error)\n    })\n\n    responseStream.on(`response`, (response) => {\n      resetTimeout()\n\n      fsWriteStream.on(`finish`, () => {\n        if (timeout) {\n          clearTimeout(timeout)\n        }\n        resolve(response)\n      })\n    })\n  })\n\n/**\n * processRemoteNode\n * --\n * Request the remote file and return the fileNode\n *\n * @param {CreateRemoteFileNodePayload} options\n * @return {Promise<Object>} Resolves with the fileNode\n */\nasync function processRemoteNode({\n  url,\n  cache,\n  createNode,\n  parentNodeId,\n  auth = {},\n  httpHeaders = {},\n  createNodeId,\n  ext,\n  name,\n}) {\n  const pluginCacheDir = cache.directory\n  // See if there's response headers for this url\n  // from a previous request.\n  const cachedHeaders = await cache.get(cacheId(url))\n\n  const headers = { ...httpHeaders }\n  if (cachedHeaders && cachedHeaders.etag) {\n    headers[`If-None-Match`] = cachedHeaders.etag\n  }\n\n  // Add htaccess authentication if passed in. This isn't particularly\n  // extensible. We should define a proper API that we validate.\n  const httpOpts = {}\n  if (auth?.htaccess_pass && auth?.htaccess_user) {\n    headers[`Authorization`] = `Basic ${btoa(\n      `${auth.htaccess_user}:${auth.htaccess_pass}`\n    )}`\n  }\n\n  // Create the temp and permanent file names for the url.\n  const digest = createContentDigest(url)\n  if (!name) {\n    name = getRemoteFileName(url)\n  }\n  if (!ext) {\n    ext = getRemoteFileExtension(url)\n  }\n\n  const tmpFilename = createFilePath(pluginCacheDir, `tmp-${digest}`, ext)\n\n  // Fetch the file.\n  const response = await requestRemoteNode(url, headers, tmpFilename, httpOpts)\n\n  if (response.statusCode == 200) {\n    // Save the response headers for future requests.\n    await cache.set(cacheId(url), response.headers)\n  }\n\n  // If the user did not provide an extension and we couldn't get one from remote file, try and guess one\n  if (ext === ``) {\n    const buffer = readChunk.sync(tmpFilename, 0, fileType.minimumBytes)\n    const filetype = fileType(buffer)\n    if (filetype) {\n      ext = `.${filetype.ext}`\n    }\n  }\n\n  const filename = createFilePath(\n    path.join(pluginCacheDir, digest),\n    String(name),\n    ext\n  )\n\n  // If the status code is 200, move the piped temp file to the real name.\n  if (response.statusCode === 200) {\n    await fs.move(tmpFilename, filename, { overwrite: true })\n    // Else if 304, remove the empty response.\n  } else {\n    processingCache[url] = null\n    totalJobs -= 1\n\n    bar.total = totalJobs\n\n    await fs.remove(tmpFilename)\n  }\n\n  // Create the file node.\n  const fileNode = await createFileNode(filename, createNodeId, {})\n  fileNode.internal.description = `File \"${url}\"`\n  fileNode.url = url\n  fileNode.parent = parentNodeId\n  // Override the default plugin as gatsby-source-filesystem needs to\n  // be the owner of File nodes or there'll be conflicts if any other\n  // File nodes are created through normal usages of\n  // gatsby-source-filesystem.\n  await createNode(fileNode, { name: `gatsby-source-filesystem` })\n\n  return fileNode\n}\n\n/**\n * Index of promises resolving to File node from remote url\n */\nconst processingCache = {}\n/**\n * pushTask\n * --\n * pushes a task in to the Queue and the processing cache\n *\n * Promisfy a task in queue\n * @param {CreateRemoteFileNodePayload} task\n * @return {Promise<Object>}\n */\nconst pushTask = (task) =>\n  new Promise((resolve, reject) => {\n    getQueue(task.limit)\n      .push(task)\n      .on(`finish`, (task) => {\n        resolve(task)\n      })\n      .on(`failed`, (err) => {\n        reject(new Error(`failed to process ${task.url}\\n${err}`))\n      })\n  })\n\n/** *************\n * Entry Point *\n ***************/\n\n/**\n * createRemoteFileNode\n * --\n *\n * Download a remote file\n * First checks cache to ensure duplicate requests aren't processed\n * Then pushes to a queue\n *\n * @param {CreateRemoteFileNodePayload} options\n * @return {Promise<Object>}                  Returns the created node\n */\nmodule.exports = ({\n  url,\n  cache,\n  createNode,\n  getCache,\n  parentNodeId = null,\n  auth = {},\n  httpHeaders = {},\n  createNodeId,\n  ext = null,\n  name = null,\n  reporter,\n  pluginOptions,\n}) => {\n  const limit = pluginOptions?.type?.MediaItem?.localFile?.requestConcurrency\n  if (doneQueueTimeout) {\n    // this is to give the bar a little time to wait when there are pauses\n    // between file downloads.\n    clearTimeout(doneQueueTimeout)\n  }\n\n  // if the url isn't already encoded\n  // so decoding it doesn't do anything\n  if (decodeURI(url) === url) {\n    // encode the uri\n    // this accounts for special characters in filenames\n    url = encodeURI(url)\n  }\n\n  // validation of the input\n  // without this it's notoriously easy to pass in the wrong `createNodeId`\n  // see gatsbyjs/gatsby#6643\n  if (typeof createNodeId !== `function`) {\n    throw new Error(\n      `createNodeId must be a function, was ${typeof createNodeId}`\n    )\n  }\n  if (typeof createNode !== `function`) {\n    throw new Error(`createNode must be a function, was ${typeof createNode}`)\n  }\n  if (typeof getCache === `function`) {\n    // use cache of this plugin and not cache of function caller\n    cache = getCache(`gatsby-source-filesystem`)\n  }\n  if (typeof cache !== `object`) {\n    throw new Error(\n      `Neither \"cache\" or \"getCache\" was passed. getCache must be function that return Gatsby cache, \"cache\" must be the Gatsby cache, was ${typeof cache}`\n    )\n  }\n\n  // Check if we already requested node for this remote file\n  // and return stored promise if we did.\n  if (processingCache[url]) {\n    return processingCache[url]\n  }\n\n  if (!url || isWebUri(url) === undefined) {\n    return Promise.reject(\n      new Error(\n        `url passed to create-remote-file-node is either missing or not a proper web uri: ${url}`\n      )\n    )\n  }\n\n  if (totalJobs === 0) {\n    bar = createProgress(`Downloading remote files`, reporter)\n    bar.start()\n  }\n\n  totalJobs += 1\n\n  bar.total = totalJobs\n\n  const fileDownloadPromise = pushTask({\n    url,\n    cache,\n    createNode,\n    parentNodeId,\n    createNodeId,\n    auth,\n    httpHeaders,\n    ext,\n    name,\n    limit,\n  })\n\n  processingCache[url] = fileDownloadPromise.then((node) => {\n    bar.tick()\n\n    return node\n  })\n\n  return processingCache[url]\n}\n"],"file":"index.js"}